//@version=5


// 流程:
// 定義高低點
// bar觸碰高低點行為
// 



// 1. Import library
import kaiku0125/Debug/1 as debug
import kaiku0125/Colour/1 as colour
import kaiku0125/Util/1 as util
// # ========================================================================= #
// #                   |   Indicator  |
// # ========================================================================= #
indicator(
 title                = "Liquidity finder",
 shorttitle           = "",
 overlay              =  true,
 max_lines_count      = 5,
 max_labels_count     = 10
 )
// # ========================================================================= #
// #                   |   Indicator  |
// # ========================================================================= #

// 2. Preference inputs settings

// 3. Constant value initialization
var int STATE_NONE = 0
var int STATE_HAS_HIGH_LOW = 1
var int STATE_HAS_TOUCHED = 2
var int STATE_HAS_STAND = 3


var float ERROR_HIGH = 0.0
var float ERROR_LOW = 1000000000.0
var int LEFT_OFFSET = 10
var int RIGHT_OFFSET = 2


// 4. Variable declartion
type LiquidBar
    float barIndex
    bool isHigh
    bool isTouched
    bool isBroke
    bool isStand

// type DetectMachine
//     int state



var state = 0

var LiquidBar[] liquidBarArray = array.new<LiquidBar>()

var float regionHigh = ERROR_HIGH
var line[] lineHighArray = array.new_line()
var bool isHighCal = false

var float regionLow = ERROR_LOW
var line[] lineLowArray = array.new_line()
var bool isLowCal = false 

var bool needCalAgain = true
var bool isBreak = true

var label breakLabel = na
var label touchLabel = na
var label standLabel = na
var label debugLabel = na

// 5. Define functions

setState(int _state) =>
    string msg = switch _state
        STATE_NONE => "等待訊號..."
        STATE_HAS_HIGH_LOW => "高低計算完成"
        STATE_HAS_TOUCHED => "觸摸"
        STATE_HAS_STAND => "跌回|收回"
        =>
            runtime.error(message = "No available state!!")
            "Run time error!"
    
    alert(msg)
    _state
    
 
    


// 6. Code logic start
LiquidBar mLiquidBar = LiquidBar.new()

float pHigh = ta.pivothigh(leftbars = LEFT_OFFSET, rightbars = RIGHT_OFFSET)
plot(pHigh, style=plot.style_cross, linewidth=3, color= color.white, offset = -RIGHT_OFFSET)

float pLow = ta.pivotlow(leftbars = LEFT_OFFSET, rightbars = RIGHT_OFFSET) 
plot(pLow, style=plot.style_circles, linewidth=3, color= color.yellow, offset = -RIGHT_OFFSET)


//計算高點
bool cond1 = not na(pHigh)
bool cond2 = pHigh > regionHigh
if cond1 and needCalAgain
    line lineHigh = line.new(x1 = bar_index - RIGHT_OFFSET, y1 = pHigh, x2 = bar_index, y2 = pHigh, color = color.red, extend = extend.right)
    array.push(id = lineHighArray, value = lineHigh)
    if array.size(id = lineHighArray) > 1
        line.delete(id = array.shift(id = lineHighArray) ) 

if cond1 and cond2
    regionHigh := pHigh


//計算低點
bool cond3 = not na(pLow)
bool cond4 = pLow < regionLow
if cond3 and needCalAgain
    line lineLow = line.new(x1 = bar_index - RIGHT_OFFSET, y1 = pLow, x2 = bar_index, y2 = pLow, color = color.green, extend = extend.right)
    array.push(id = lineLowArray, value = lineLow)
    if array.size(id = lineLowArray) > 1
        line.delete(id = array.shift(id = lineLowArray) ) 

if cond3 and cond4
    regionLow := pLow

//如果都計算完畢
if needCalAgain and regionHigh != ERROR_HIGH and regionLow != ERROR_LOW
    needCalAgain := false

//是否觸碰最高
bool crossUp = false
bool touchUp = false
bool standUp = false
for lineHigh in lineHighArray
    float linePriceHigh = line.get_y1(lineHigh)
    
    
    bool newCrossUp = close[1] < linePriceHigh and close > linePriceHigh
    crossUp := newCrossUp


    bool newTouchUp = high > linePriceHigh
    touchUp := newTouchUp

    bool newStandUp = high[1] > linePriceHigh and close < linePriceHigh
    standUp := newStandUp

    if crossUp
        needCalAgain := true
        regionHigh := ERROR_HIGH
        regionLow := ERROR_LOW
        breakLabel := label.new(bar_index, high * 1.01, "破高", color = color.black, textcolor = color.orange, style = label.style_label_down)
        label.delete(id = breakLabel[2])
        
    if touchUp and not crossUp and regionHigh != ERROR_HIGH
        touchLabel := label.new(bar_index, high * 1.01, "觸高", color = color.black, textcolor = color.green, style = label.style_label_down)
        label.delete(id = touchLabel[2])

    if standUp
        standLabel := label.new(bar_index, high * 1.05, "跌回", color = color.teal, textcolor = color.white, style = label.style_label_down)
        label.delete(id = standLabel[1])
        
    

//是否觸碰最低
bool crossDown = false
bool touchDown = false
bool standDown = false
for lineLow in lineLowArray
    float linePriceLow = line.get_y1(lineLow)

    bool newCrossDown = close[1] > linePriceLow and close < linePriceLow
    crossDown := newCrossDown

    bool newTouchDown = low < linePriceLow
    touchDown := newTouchDown

    bool newStandDown = low[1] < linePriceLow and close > linePriceLow
    standDown := newStandDown

    if crossDown
        needCalAgain := true
        regionHigh := ERROR_HIGH
        regionLow := ERROR_LOW
        breakLabel := label.new(bar_index, low * 0.99, "破低", color = color.black, textcolor = color.orange, style = label.style_label_up)
        label.delete(id = breakLabel[2])

    if touchDown and not crossDown and regionLow != ERROR_LOW
        touchLabel := label.new(bar_index, low * 0.99, "觸低", color = color.black, textcolor = color.red, style = label.style_label_up)
        label.delete(id = touchLabel[2])
        alert("觸低啦")

    
    if standDown
        standLabel := label.new(bar_index, low * 0.95, "收回", color = color.teal, textcolor = color.white, style = label.style_label_up)
        label.delete(id = standLabel[1])
        

string outputText = "高 : " +  str.tostring(value = regionHigh) + "\n" + "低 : " +  str.tostring(value = regionLow)
debugLabel := debug.printLabel(outputText)
label.delete(id = debugLabel[1])


// if barstate.islast


// if close[1] > regionHigh and regionHigh != 0.0
//     debugLabel := debug.printLabel("破")
//     isBreak  := true
//     regionHigh := 0
    
    

// if close[1] < regionLow and regionLow != 1000000000.0
//     debugLabel := debug.printLabel("破")
//     isBreak := true
//     regionLow := 1000000000

// bool crossUp = false
// for lineHigh in lineHighArray
//     float linePrice = line.get_y1(lineHigh)
//     bool newCrossUp = close[1] < linePrice and close > linePrice
//     // bool newCrossDn = close[1] > linePrice and close < linePrice
//     crossUp := newCrossUp

// if crossUp
//     needCalAgain := true
//     debugLabel := debug.printLabel("破")


// // Alert.
// if cross
//     alert("A cross has occurred")

// plotchar(cross, "Cross", "X", color = color.white)
